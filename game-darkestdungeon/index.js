const Promise = require('bluebird');
const path = require('path');
const winapi = require('winapi-bindings');
const { parseStringPromise } = require('xml2js');
const { fs, log, util } = require('vortex-api');

let _API;
let _GAME_MODS_FOLDER;
const _DIRECTORY_STRUCT = [];

const GOG_ID = '1450711444';
const STEAM_ID = '262060';

const GOG_EXE = '_windowsnosteam/win64/Darkest.exe';
const STEAM_EXE = '_windows/win64/Darkest.exe';

// Nexus Mods id for the game.
const GAME_ID = 'darkestdungeon';

const HERO_PORTRAIT_SUFFIX = '_portrait_roster.png';

// We expect mods to have the project.xml file included.
const PROJECT_FILE = 'project.xml';

const PROJECT_TEMPLATE =
`<?xml version="1.0" encoding="utf-8"?>
<project>
    <PreviewIconFile>preview_icon.png</PreviewIconFile>
    <ItemDescriptionShort/>
    <ModDataPath>{{modPath}}</ModDataPath>
    <Title>{{title}}</Title>
    <Language>english</Language>
    <UpdateDetails/>
    <Visibility>public</Visibility>
    <UploadMode>direct_upload</UploadMode>
    <VersionMajor>1</VersionMajor>
    <VersionMinor>0</VersionMinor>
    <TargetBuild>0</TargetBuild>
    <Tags>
    </Tags>
    <ItemDescription>File generated by Vortex</ItemDescription>
</project>`

function getModsFolder() {
  if (_GAME_MODS_FOLDER !== undefined) {
    return _GAME_MODS_FOLDER;
  }
  const state = _API.store.getState();
  const discovery = util.getSafe(state, ['settings', 'gameMode', 'discovered', GAME_ID], undefined);
  if (discovery?.path === undefined) {
    throw new util.ProcessCanceled('Game is not discovered!');
  }
  _GAME_MODS_FOLDER = path.join(discovery.path, 'mods');
  return _GAME_MODS_FOLDER;
}

function walkAsync(dir, gamePathIndex) {
  let modsFolder;
  try {
    modsFolder = getModsFolder();
  } catch (err) {
    return Promise.reject(err);
  }
  if(path.relative(dir, modsFolder) === 'mods') {
    gamePathIndex = dir.length + 1;
  }
  return fs.readdirAsync(dir).then(files => {
    return Promise.map(files, file => {
      const fullPath = path.join(dir, file);
      return fs.statAsync(fullPath).then(stats => {
        if (stats.isDirectory()) {
          _DIRECTORY_STRUCT.push(fullPath.substr(gamePathIndex));
          return walkAsync(fullPath, gamePathIndex)
            .then(dirs => {
              _DIRECTORY_STRUCT.concat(dirs);
              return Promise.resolve();
            })
        } else {
          return Promise.resolve()
        }
      })
      .catch(err => {
        // The point of this function is to map out the game's
        //  directory structure - any errors raised during mapping
        //  simply signfies an unavailable path and therefore
        //  shouldn't block the rest of the process (we log instead)
        log('warn', '[DD] unable to add file to dir struct', err);
        return Promise.resolve()
      })
    })
    .then(() => Promise.resolve(_DIRECTORY_STRUCT));
  });
}

function readRegistryKey(hive, key, name) {
  try {
    const instPath = winapi.RegGetValue(hive, key, name);
    if (!instPath) {
      throw new Error('empty registry key');
    }
    return Promise.resolve(instPath.value);
  } catch (err) {
    return Promise.resolve(undefined);
  }
}

function findGame() {
  return util.steam.findByAppId(STEAM_ID)
    .then(game => game.gamePath)
    .catch(() => readRegistryKey('HKEY_LOCAL_MACHINE',
      `SOFTWARE\\WOW6432Node\\GOG.com\\Games\\${GOG_ID}`,
      'PATH'))
    .catch(() => readRegistryKey('HKEY_LOCAL_MACHINE',
      `SOFTWARE\\GOG.com\\Games\\${GOG_ID}`,
      'PATH'))
}

function prepareForModding(discovery) {
  return walkAsync(discovery.path, 0)
    .then(() => {
      // Add the dlc folder if it's missing.
      if (_DIRECTORY_STRUCT.find(entry => entry.toLowerCase() === 'dlc') === undefined) {
        _DIRECTORY_STRUCT.push('dlc');
      }

      return fs.ensureDirWritableAsync(getModsFolder(), () => Promise.resolve())
    })
}

async function setModDataPath(projectFilePath, modPath) {
  let projectData;
  return fs.readFileAsync(projectFilePath)
    .then(async xmlData => {
      try {
        projectData = await parseStringPromise(xmlData);
        return writeProjectFile(projectFilePath, projectData?.project?.Title, modPath);
      } catch (err) {
        return Promise.reject(new util.DataInvalid('Failed to parse project file.'))
      }
    })
}

function writeProjectFile(projectFilePath, title, modPath) {
  let projectFile = PROJECT_TEMPLATE.replace('{{title}}', title);
  projectFile = projectFile.replace('{{modPath}}', modPath);
  return fs.writeFileAsync(projectFilePath, projectFile, { encoding: 'utf-8' });
}

function installProject(files, destinationPath) {
  const projectFile = files.find(file => path.basename(file).toLowerCase() === PROJECT_FILE);
  const idx = projectFile.indexOf(path.basename(projectFile));
  const rootPath = path.dirname(projectFile);
  const modName = path.basename(destinationPath, '.installing')
    .replace(/[^A-Za-z]/g, '');
  let expectedModPath;
  try {
    expectedModPath = path.join(getModsFolder(), modName);
  } catch (err) {
    return Promise.reject(err);
  }
  return setModDataPath(path.join(destinationPath, projectFile), expectedModPath)
    .then(() => {
      // Remove directories and anything that isn't in the rootPath.
      const filtered = files.filter(file =>
        ((file.indexOf(rootPath) !== -1)
        && (!file.endsWith(path.sep))));

      const instructions = filtered.map(file => {
        return {
          type: 'copy',
          source: file,
          destination: path.join(modName, file.substr(idx)),
        };
      });

      return Promise.resolve({ instructions });
    })
}

function testSupportedProject(files, gameId) {
  if (process.platform !== 'win32') {
    // Windows only for now.
    return Promise.resolve({supported: false, requiredFiles: []});
  }

  // Make sure we're able to support this mod.
  const supported = (gameId === GAME_ID) &&
    (files.find(file => path.basename(file).toLowerCase() === PROJECT_FILE) !== undefined);
  return Promise.resolve({
    supported,
    requiredFiles: [],
  });
}

function testSupportedNoProject(files, gameId) {
  if ((process.platform !== 'win32')
    || (gameId !== GAME_ID)
    || (files.find(file => path.basename(file) === PROJECT_FILE) !== undefined)) {
    // - We only support Windows for now due to the executable location.
    // - Ensure we don't use this custom installer for other gameModes.
    // - Ensure we don't have a project file.
    return Promise.resolve({supported: false, requiredFiles: []});
  }

  const filtered = files.filter(file => file.endsWith(path.sep));

  // Filter files with the _portrait_roster.png suffix as it's safe to assume that those
  //  are hero mods.
  const portraits = files.filter(file => file.indexOf(HERO_PORTRAIT_SUFFIX) !== -1);

  // Mod is supported if the file structure matches the game's dir structure OR
  //  if we are able to find portraits within the mod's archive.
  const supported = ((filtered.find(file => _DIRECTORY_STRUCT.find(dir =>
        file.indexOf(dir) !== -1) !== undefined) !== undefined)
    || (portraits.length > 0));

  return Promise.resolve({
    supported,
    requiredFiles: [],
  });
}

function installNoProject(files, destinationPath) {
  const matchDirStructure = (file) =>
    _DIRECTORY_STRUCT.find(dir => path.dirname(file).indexOf(dir) !== -1) !== undefined;

  const matchParentDirs = (lhs, rhs) => {
    // Checks whether both lhs and rhs have the same
    //  parent directory.
    const lhsParent = lhs.endsWith(path.sep)
      ? lhs.split(path.sep)
      : path.dirname(lhs).split(path.sep);
    lhsParent.pop();

    const rhsParent = rhs.endsWith(path.sep)
      ? rhs.split(path.sep)
      : path.dirname(rhs).split(path.sep);
    rhsParent.pop();

    return lhsParent.join(path.sep) === rhsParent.join(path.sep);
  }

  const onlyFiles = files.filter(file => path.extname(path.basename(file)) !== '');
  const portraits = onlyFiles.filter(file => file.indexOf(HERO_PORTRAIT_SUFFIX) !== -1);

  const findExternalHeroFiles = (dirStruct, portraitPath, destPath) => {
    // Hero mods may include additional files located inside the Hero's root path.
    //  we add those separately for each portrait/hero path.
    const diff = onlyFiles.filter(file =>
      dirStruct.find(dir => file === dir.source) === undefined);

    const files = [];
    diff.forEach(element => {
      if (matchParentDirs(element, portraitPath)) {
        files.push({
          source: element,
          destination: path.join(destPath, element),
        });
      }
    });

    return files;
  }

  let dirStructure = onlyFiles.filter(file => {
    // Hero mods have certain directories (e.g. heroes/fx) which will match
    //  the root game's folder structure causing Vortex to wrongly add them to
    //  the wrong directory layer i.e. ../heroes/fx folder to ../fx, reason why
    //  we need to check whether the file's parent directory matches the portrait
    //  root.
    //  (this depends on how the mod author packaged his mod)
    return (portraits.length > 0)
      ? matchDirStructure(file) && (!matchParentDirs(portraits[0], file))
      : matchDirStructure(file);
  });

  const heroesRoot = 'heroes';
  if (dirStructure.length === 0) {
    // We couldn't find a matching directory structure. This is _probably_ a
    //  hero mod. We're going to populate dirStructure with the expected directory
    //  structure automatically.
    portraits.forEach(portrait => {
      const portraitDir = path.dirname(portrait);
      const idx = portrait.indexOf(path.basename(portrait));
      const heroSuffix = portraitDir.substr(portraitDir.length - 2);
      const heroFiles = onlyFiles.filter(file => file.indexOf(portraitDir) !== -1);
      let heroName = portraitDir.replace(/_[A-Z]/g, '').split(path.sep);
      heroName = heroName[heroName.length - 1];
      const heroPath = path.join(heroesRoot, heroName);
      dirStructure = dirStructure.concat(findExternalHeroFiles(dirStructure, portraitDir, heroPath));
      dirStructure = dirStructure.concat(heroFiles.map(file => {
        return {
          source: file,
          destination: path.join(heroesRoot, heroName, heroName + heroSuffix, file.substr(idx)),
        };
      }));
    });

  } else {
    // The file structure has been correctly identified.
    dirStructure = dirStructure.map(file => {
      return {
        source: file,
        destination: file,
      };
    })

    const leftOver = onlyFiles.filter(file =>
         (dirStructure.find(x => x.source === file) === undefined)
      && (file.split(path.sep).indexOf(heroesRoot) !== -1));

    dirStructure = dirStructure.concat(leftOver.map(file => {
      const segments = file.split(path.sep);
      const idx = segments.indexOf(heroesRoot);
      const destination = segments.slice(idx).join(path.sep);
      return {
        source: file,
        destination,
      }
    }));
  }

  const modName = path.basename(destinationPath, '.installing')
    .replace(/[^A-Za-z]/g, '');
  let expectedModPath;
  try {
    expectedModPath = path.join(getModsFolder(), modName);
  } catch (err) {
    return Promise.reject(err);
  }
  return writeProjectFile(path.join(destinationPath, PROJECT_FILE), modName, expectedModPath)
    .then(() => {
      dirStructure.push({
        source: PROJECT_FILE,
        destination: PROJECT_FILE,
      });
      const instructions = dirStructure.map(file => {
        return {
          type: 'copy',
          source: file.source,
          destination: path.join(modName, file.destination),
        };
      });

      return Promise.resolve({ instructions });
    })
}

function getExecutable(discoveryPath) {
  const getDiscoveryPath = () => {
    const state = _API.store.getState();
    const discovery = util.getSafe(state, ['settings', 'gameMode', 'discovered', GAME_ID], undefined);
    return (discovery !== undefined)
      ? discovery.path
      : undefined;
  }

  if ((discoveryPath === undefined) && (getDiscoveryPath() === undefined)) {
    return STEAM_EXE;
  }

  const discPath = (discoveryPath !== undefined)
    ? discoveryPath
    : getDiscoveryPath();

  let execFile = GOG_EXE;
  try {
    fs.statSync(path.join(discPath, GOG_EXE))
  } catch (err) {
    execFile = STEAM_EXE;
  }

  return execFile;
}

function main(context) {
  _API = context.api;
  context.registerGame({
    id: GAME_ID,
    name: 'Darkest Dungeon',
    mergeMods: true,
    queryPath: findGame,
    queryModPath: () => 'mods',
    logo: 'gameart.jpg',
    executable: (discoveryPath) => getExecutable(discoveryPath),
    requiredFiles: [
      GOG_EXE,
    ],
    setup: prepareForModding,
    environment: {
      SteamAPPId: STEAM_ID,
    },
    details: {
      steamAppId: parseInt(STEAM_ID),
      hashFiles: [GOG_EXE], // Both Steam and GOG builds have the GOG exec present.
    },
  });

  context.registerInstaller('dd-project-mod', 25, testSupportedProject, installProject);
  context.registerInstaller('dd-noproject-mod', 25, testSupportedNoProject, installNoProject);

  return true;
}

module.exports = {
  default: main,
};
